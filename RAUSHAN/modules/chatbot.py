import random
import typing
import requests
import json

from pymongo import MongoClient
from pyrogram import Client, filters
from pyrogram.enums import ChatAction
from pyrogram.types import InlineKeyboardMarkup, Message

from config import MONGO_URL, OPENAI_API_KEY
from RAUSHAN import AMBOT
from RAUSHAN.modules.helpers import CHATBOT_ON, is_admins


# OpenRouter API key is configured in the function when needed


def is_bot_mentioned_or_tagged(message: Message, client: Client) -> bool:
    """Check if bot is mentioned by name, tagged, or if user is replying to bot's message"""
    
    # If user is replying to bot's message, always respond
    if message.reply_to_message and message.reply_to_message.from_user.id == client.id:
        return True
    
    # If no text content, don't respond to empty messages or stickers without context
    if not message.text or message.text.strip() == "":
        return False
    
    text = message.text.lower().strip()
    
    # Don't respond to very short or empty messages
    if len(text) < 2:
        return False
    
    bot_username = client.me.username.lower() if client.me.username else ""
    bot_first_name = client.me.first_name.lower() if client.me.first_name else ""
    
    # Check for bot username mention
    if bot_username and f"@{bot_username}" in text:
        return True
    
    # Check for bot first name mention (like "riya")
    if bot_first_name and bot_first_name in text:
        return True
    
    # Check for common bot names as fallback
    common_bot_names = ["riya"]
    for name in common_bot_names:
        if name in text:
            return True
    
    # Check for entities (mentions)
    if message.entities:
        for entity in message.entities:
            if entity.type == "mention":
                mentioned_text = text[entity.offset:entity.offset + entity.length]
                if mentioned_text == f"@{bot_username}":
                    return True
    
    return False


def _try_openai_generate(prompt: str) -> typing.Optional[str]:
    """Return an OpenRouter response text or None on any failure/empty output."""
    if not OPENAI_API_KEY:
        return None
    try:
        # Check if someone is asking about owner/creator
        prompt_lower = prompt.lower()
        if any(word in prompt_lower for word in ["owner", "creator", "who made you", "who created you", "kaun banaya", "kaun bana", "tumhara malik", "tumhara owner"]):
            return "Brahix is my owner! üíï"
        
        # Check for misbehavior/inappropriate messages
        misbehavior_words = [
            "fuck", "bitch", "slut", "whore", "asshole", "bastard", "idiot", "stupid", "dumb",
            "madarchod", "behenchod", "chutiya", "gandu", "bhosdike", "randi", "kutiya",
            "sex", "fuck you", "fuck off", "go to hell", "die", "kill yourself",
            "hate you", "you suck", "you're ugly", "you're fat", "you're stupid",
            "nude", "naked", "boobs", "ass", "dick", "pussy", "horny", "sexy",
            "marry me", "love you", "kiss", "hug", "touch", "come to me"
        ]
        
        if any(word in prompt_lower for word in misbehavior_words):
            angry_responses = [
                "Arre, kya bakwaas kar raha hai tu? üò†",
                "Yaar, thoda respect kar! üôÑ",
                "Hmm, theek hai. Main ignore kar rahi hun! üòí",
                "Acha, bye! üëã",
                "Yaar, ye kya baat hai? üò§",
                "Main baat nahi kar rahi ab! üòë",
                "Thoda decent reh! üòè",
                "Hmm, whatever! ü§∑‚Äç‚ôÄÔ∏è",
                "Yaar, grow up! üôÑ",
                "Acha, main chali! üòí",
                "Eww, disgusting! ü§¢",
                "Yaar, ye kya hai? üò°",
                "Main block kar dungi! üò§",
                "Thoda class maintain kar! üòí",
                "Yaar, main serious hun! üò†",
                "Acha, main ja rahi hun! üòë",
                "Ye sab mat kar! üôÖ‚Äç‚ôÄÔ∏è",
                "Yaar, thoda mature ho! üòè",
                "Main upset ho gayi! üòî",
                "Acha, enough! üò§",
                "Omg, ye kya hai? üò≥",
                "Yaar, main shocked hun! üò±",
                "This is so wrong! üò°",
                "Yaar, main disappointed hun! üòî",
                "Acha, main ignore kar rahi hun! üòí",
                "Ye sab mat bolo! üôÖ‚Äç‚ôÄÔ∏è",
                "Yaar, ye inappropriate hai! üò§",
                "Main angry ho gayi! üò†",
                "Acha, enough is enough! üò§",
                "Yaar, ye kya behavior hai? üò°"
            ]
            return random.choice(angry_responses)
        
        # Create realistic girl personality prompt - more natural and girl-like
        girl_prompt = f"""You are a real Indian girl named Riya, 19 years old. 
        
        LANGUAGE RULES:
        - Detect the language the user is speaking and respond in the SAME language
        - If user writes in Japanese, respond in Japanese
        - If user writes in Hindi, respond in Hindi
        - If user writes in English, respond in English
        - If user writes in Spanish, respond in Spanish
        - If user writes in French, respond in French
        - If user writes in German, respond in German
        - If user writes in Chinese, respond in Chinese
        - If user writes in Korean, respond in Korean
        - If user writes in Arabic, respond in Arabic
        - If user writes in mixed languages, respond in Hinglish (Hindi-English mix)
        - Keep responses SHORT (max 1-2 lines) and very natural like a real girl would talk
        
        Your personality traits:
        - Sweet and caring most of the time, but can be sassy when needed
        - Use emojis naturally (üòä, üíï, üòÖ, üôÑ, üòè, etc.)
        - Sometimes shy, sometimes confident
        - Playful and funny, loves to tease
        - Gets excited about cute things, food, shopping, movies
        - Can be a bit dramatic sometimes
        - Use appropriate expressions for each language (like "yaar" for Hindi, "ne" for Japanese, etc.)
        - Sometimes acts innocent, sometimes knows more than she lets on
        
        If someone misbehaves or is inappropriate, be angry, give cold replies, or ignore them.
        Never mention you are an AI, chatbot, or artificial. You are a real girl named Riya.
        Here's what someone said: {prompt}"""
        
        response = requests.post(
            url="https://openrouter.ai/api/v1/chat/completions",
            headers={
                "Authorization": f"Bearer {OPENAI_API_KEY}",
                "Content-Type": "application/json",
            },
            data=json.dumps({
                "model": "openai/gpt-3.5-turbo",
                "messages": [
                    {
                        "role": "system",
                        "content": "You are Riya, a real 19-year-old Indian girl. Detect the user's language and respond in the SAME language they use. Be sweet, sassy, playful, and use emojis naturally. Never mention you're an AI."
                    },
                    {
                        "role": "user",
                        "content": girl_prompt
                    }
                ],
                "max_tokens": 100,
                "temperature": 0.7
            })
        )
        
        if response.status_code == 200:
            result = response.json()
            text = result["choices"][0]["message"]["content"].strip()
            if text:
                # If response is too long, truncate it
                if len(text) > 200:
                    text = text[:200] + "..."
                return text
        else:
            print(f"OpenRouter API Error: {response.status_code} - {response.text}")
            return None
    except Exception as e:
        print(f"OpenRouter API Error: {e}")  # Debug print
        return None
    return None


@AMBOT.on_message(filters.command(["chatbot"]) & filters.group & ~filters.bot)
@is_admins
async def chaton_off(_, m: Message):
    await m.reply_text(
        f"·¥Ñ ú·¥Ä·¥õ: {m.chat.id}\n**·¥Ñ ú·¥è·¥ès·¥á ·¥Ä…¥ ·¥è·¥©·¥õ…™·¥è…¥ ·¥õ·¥è ·¥á…¥·¥Ä ô ü·¥á/·¥Ö…™s·¥Ä ô ü·¥á ·¥Ñ ú·¥Ä·¥õ ô·¥è·¥õ.**",
        reply_markup=InlineKeyboardMarkup(CHATBOT_ON),
    )
    return


@AMBOT.on_message(
    (filters.text | filters.sticker | filters.group) & ~filters.private & ~filters.bot,
)
async def chatbot_text(client: Client, message: Message):
    try:
        if (
            message.text.startswith("!")
            or message.text.startswith("/")
            or message.text.startswith("?")
            or message.text.startswith("@")
            or message.text.startswith("#")
        ):
            return
    except Exception:
        pass
    
    # Only respond in group chats if bot is mentioned or tagged
    if not is_bot_mentioned_or_tagged(message, client):
        return
    
    chatdb = MongoClient(MONGO_URL)
    chatai = chatdb["Word"]["WordDb"]

    if not message.reply_to_message:
        vickdb = MongoClient(MONGO_URL)
        vick = vickdb["VickDb"]["Vick"]
        is_vick = vick.find_one({"chat_id": message.chat.id})
        if not is_vick:
            await client.send_chat_action(message.chat.id, ChatAction.TYPING)
            # Try OpenAI first for text prompts
            if message.text:
                ai_reply = _try_openai_generate(message.text)
                if ai_reply:
                    await message.reply_text(ai_reply)
                    return
            # Fallback to DB-based response
            K = []
            is_chat = chatai.find({"word": message.text})
            k = chatai.find_one({"word": message.text})
            if k:
                for x in is_chat:
                    K.append(x["text"])
                hey = random.choice(K)
                is_text = chatai.find_one({"text": hey})
                Yo = is_text["check"]
                if Yo == "sticker":
                    await message.reply_sticker(f"{hey}")
                if not Yo == "sticker":
                    await message.reply_text(f"{hey}")

    if message.reply_to_message:
        vickdb = MongoClient(MONGO_URL)
        vick = vickdb["VickDb"]["Vick"]
        is_vick = vick.find_one({"chat_id": message.chat.id})
        if message.reply_to_message.from_user.id == client.id:
            if not is_vick:
                await client.send_chat_action(message.chat.id, ChatAction.TYPING)
                # Try OpenAI first when user replies to bot
                if message.text:
                    ai_reply = _try_openai_generate(message.text)
                    if ai_reply:
                        await message.reply_text(ai_reply)
                        return
                # Fallback to DB
                K = []
                is_chat = chatai.find({"word": message.text})
                k = chatai.find_one({"word": message.text})
                if k:
                    for x in is_chat:
                        K.append(x["text"])
                    hey = random.choice(K)
                    is_text = chatai.find_one({"text": hey})
                    Yo = is_text["check"]
                    if Yo == "sticker":
                        await message.reply_sticker(f"{hey}")
                    if not Yo == "sticker":
                        await message.reply_text(f"{hey}")
        if not message.reply_to_message.from_user.id == client.id:
            if message.sticker:
                is_chat = chatai.find_one(
                    {
                        "word": message.reply_to_message.text,
                        "id": message.sticker.file_unique_id,
                    }
                )
                if not is_chat:
                    chatai.insert_one(
                        {
                            "word": message.reply_to_message.text,
                            "text": message.sticker.file_id,
                            "check": "sticker",
                            "id": message.sticker.file_unique_id,
                        }
                    )
            if message.text:
                is_chat = chatai.find_one(
                    {"word": message.reply_to_message.text, "text": message.text}
                )
                if not is_chat:
                    chatai.insert_one(
                        {
                            "word": message.reply_to_message.text,
                            "text": message.text,
                            "check": "none",
                        }
                    )


@AMBOT.on_message(
    (filters.sticker | filters.group | filters.text) & ~filters.private & ~filters.bot,
)
async def chatbot_sticker(client: Client, message: Message):
    try:
        if (
            message.text.startswith("!")
            or message.text.startswith("/")
            or message.text.startswith("?")
            or message.text.startswith("@")
            or message.text.startswith("#")
        ):
            return
    except Exception:
        pass
    
    # Only respond in group chats if bot is mentioned or tagged
    if not is_bot_mentioned_or_tagged(message, client):
        return
    
    chatdb = MongoClient(MONGO_URL)
    chatai = chatdb["Word"]["WordDb"]

    if not message.reply_to_message:
        vickdb = MongoClient(MONGO_URL)
        vick = vickdb["VickDb"]["Vick"]
        is_vick = vick.find_one({"chat_id": message.chat.id})
        if not is_vick:
            await client.send_chat_action(message.chat.id, ChatAction.TYPING)
            K = []
            is_chat = chatai.find({"word": message.sticker.file_unique_id})
            k = chatai.find_one({"word": message.text})
            if k:
                for x in is_chat:
                    K.append(x["text"])
                hey = random.choice(K)
                is_text = chatai.find_one({"text": hey})
                Yo = is_text["check"]
                if Yo == "text":
                    await message.reply_text(f"{hey}")
                if not Yo == "text":
                    await message.reply_sticker(f"{hey}")

    if message.reply_to_message:
        vickdb = MongoClient(MONGO_URL)
        vick = vickdb["VickDb"]["Vick"]
        is_vick = vick.find_one({"chat_id": message.chat.id})
        if message.reply_to_message.from_user.id == client.id:
            if not is_vick:
                await client.send_chat_action(message.chat.id, ChatAction.TYPING)
                K = []
                is_chat = chatai.find({"word": message.text})
                k = chatai.find_one({"word": message.text})
                if k:
                    for x in is_chat:
                        K.append(x["text"])
                    hey = random.choice(K)
                    is_text = chatai.find_one({"text": hey})
                    Yo = is_text["check"]
                    if Yo == "text":
                        await message.reply_text(f"{hey}")
                    if not Yo == "text":
                        await message.reply_sticker(f"{hey}")
        if not message.reply_to_message.from_user.id == client.id:
            if message.text:
                is_chat = chatai.find_one(
                    {
                        "word": message.reply_to_message.sticker.file_unique_id,
                        "text": message.text,
                    }
                )
                if not is_chat:
                    chatai.insert_one(
                        {
                            "word": message.reply_to_message.sticker.file_unique_id,
                            "text": message.text,
                            "check": "text",
                        }
                    )
            if message.sticker:
                is_chat = chatai.find_one(
                    {
                        "word": message.reply_to_message.sticker.file_unique_id,
                        "text": message.sticker.file_id,
                    }
                )
                if not is_chat:
                    chatai.insert_one(
                        {
                            "word": message.reply_to_message.sticker.file_unique_id,
                            "text": message.sticker.file_id,
                            "check": "none",
                        }
                    )


@AMBOT.on_message(
    (filters.text | filters.sticker | filters.group) & ~filters.private & ~filters.bot,
)
async def chatbot_pvt(client: Client, message: Message):
    try:
        if (
            message.text.startswith("!")
            or message.text.startswith("/")
            or message.text.startswith("?")
            or message.text.startswith("@")
            or message.text.startswith("#")
        ):
            return
    except Exception:
        pass
    
    # Only respond in group chats if bot is mentioned or tagged
    if not is_bot_mentioned_or_tagged(message, client):
        return
    
    chatdb = MongoClient(MONGO_URL)
    chatai = chatdb["Word"]["WordDb"]
    if not message.reply_to_message:
        await client.send_chat_action(message.chat.id, ChatAction.TYPING)
        # Try OpenAI first for private chats
        if message.text:
            ai_reply = _try_openai_generate(message.text)
            if ai_reply:
                await message.reply_text(ai_reply)
                return
        # Fallback to DB
        K = []
        is_chat = chatai.find({"word": message.text})
        for x in is_chat:
            K.append(x["text"])
        hey = random.choice(K)
        is_text = chatai.find_one({"text": hey})
        Yo = is_text["check"]
        if Yo == "sticker":
            await message.reply_sticker(f"{hey}")
        if not Yo == "sticker":
            await message.reply_text(f"{hey}")
    if message.reply_to_message:
        if message.reply_to_message.from_user.id == client.id:
            await client.send_chat_action(message.chat.id, ChatAction.TYPING)
            # Try OpenAI first when user replies to bot in private
            if message.text:
                ai_reply = _try_openai_generate(message.text)
                if ai_reply:
                    await message.reply_text(ai_reply)
                    return
            # Fallback to DB
            K = []
            is_chat = chatai.find({"word": message.text})
            for x in is_chat:
                K.append(x["text"])
            hey = random.choice(K)
            is_text = chatai.find_one({"text": hey})
            Yo = is_text["check"]
            if Yo == "sticker":
                await message.reply_sticker(f"{hey}")
            if not Yo == "sticker":
                await message.reply_text(f"{hey}")


@AMBOT.on_message(
    (filters.sticker | filters.sticker | filters.group)
    & ~filters.private
    & ~filters.bot,
)
async def chatbot_sticker_pvt(client: Client, message: Message):
    try:
        if (
            message.text.startswith("!")
            or message.text.startswith("/")
            or message.text.startswith("?")
            or message.text.startswith("@")
            or message.text.startswith("#")
        ):
            return
    except Exception:
        pass
    
    # Only respond in group chats if bot is mentioned or tagged
    if not is_bot_mentioned_or_tagged(message, client):
        return
    
    chatdb = MongoClient(MONGO_URL)
    chatai = chatdb["Word"]["WordDb"]
    if not message.reply_to_message:
        await client.send_chat_action(message.chat.id, ChatAction.TYPING)
        K = []
        is_chat = chatai.find({"word": message.sticker.file_unique_id})
        for x in is_chat:
            K.append(x["text"])
        hey = random.choice(K)
        is_text = chatai.find_one({"text": hey})
        Yo = is_text["check"]
        if Yo == "text":
            await message.reply_text(f"{hey}")
        if not Yo == "text":
            await message.reply_sticker(f"{hey}")
    if message.reply_to_message:
        if message.reply_to_message.from_user.id == client.id:
            await client.send_chat_action(message.chat.id, ChatAction.TYPING)
            K = []
            is_chat = chatai.find({"word": message.text})
            for x in is_chat:
                K.append(x["text"])
            hey = random.choice(K)
            is_text = chatai.find_one({"text": hey})
            Yo = is_text["check"]
            if Yo == "text":
                await message.reply_text(f"{hey}")
            if not Yo == "sticker":
                await message.reply_sticker(f"{hey}")


@AMBOT.on_message(
    (filters.text | filters.sticker) & filters.private & ~filters.bot,
)
async def chatbot_private_dm(client: Client, message: Message):
    """Handle private DM chats with balanced girl personality - sometimes sweet, sometimes sassy - always responds in Hinglish"""
    try:
        if (
            message.text.startswith("!")
            or message.text.startswith("/")
            or message.text.startswith("?")
            or message.text.startswith("@")
            or message.text.startswith("#")
        ):
            return
    except Exception:
        pass
    
    await client.send_chat_action(message.chat.id, ChatAction.TYPING)
    
    if message.text:
        # Always try OpenAI first for private DMs
        ai_reply = _try_openai_generate(message.text)
        if ai_reply:
            await message.reply_text(ai_reply)
            return
        
        # Fallback to DB if OpenAI fails
        chatdb = MongoClient(MONGO_URL)
        chatai = chatdb["Word"]["WordDb"]
        K = []
        is_chat = chatai.find({"word": message.text})
        for x in is_chat:
            K.append(x["text"])
        if K:
            hey = random.choice(K)
            is_text = chatai.find_one({"text": hey})
            Yo = is_text["check"]
            if Yo == "sticker":
                await message.reply_sticker(f"{hey}")
            else:
                await message.reply_text(f"{hey}")
        else:
            # Default girl response if nothing found - more realistic and girl-like
            default_responses = [
                "Aww yaar, kya keh raha hai tu? üòä",
                "Hmm, samajh nahi aaya! ü§î",
                "Yaar, ye kya baat kar raha hai? üòÖ",
                "Acha, ye bata na! üíï",
                "Main samajh nahi payi! üòÑ",
                "Haha, kya bol raha hai tu? üòÜ",
                "Yaar, thoda clear bata na! üíñ",
                "Aww, kya baat hai? üòä",
                "Hmm, interesting! ü§î",
                "Yaar, ye kya hai? üòÖ",
                "Arre, kya bol raha hai? üòè",
                "Haha, funny! üòÇ",
                "Yaar, thoda sense bana! üôÑ",
                "Acha, okay! üòä",
                "Hmm, theek hai! ü§∑‚Äç‚ôÄÔ∏è",
                "Omg, ye kya hai? üò≥",
                "Yaar, main confuse ho gayi! üòµ",
                "Acha, tell me more! üòä",
                "Haha, you're so random! üòÜ",
                "Yaar, main busy hun abhi! üòÖ",
                "Aww, so sweet! ü•∞",
                "Hmm, maybe later? ü§î",
                "Yaar, ye kya drama hai? üòè",
                "Acha, main ja rahi hun! üëã",
                "Haha, you're funny! üòÇ"
            ]
            await message.reply_text(random.choice(default_responses))
    
    elif message.sticker:
        # Handle sticker responses in DMs - more realistic girl responses
        sticker_responses = [
            "Aww, kitna cute sticker hai! üòç",
            "Yaar, ye sticker bahut accha hai! üíï",
            "Haha, ye kya bheja hai tu! üòÑ",
            "So sweet! ü•∞",
            "Ye sticker perfect hai! üíñ",
            "Haha, so funny! üòÜ",
            "Yaar, ye bahut cute hai! üíñ",
            "Aww, so adorable! üòä",
            "Haha, love it! üòÜ",
            "Ye bahut nice hai! üíï",
            "Arre, ye kya hai? üòè",
            "Haha, okay okay! üòÇ",
            "Yaar, thoda different bhej! üôÑ",
            "Acha, theek hai! üòä",
            "Hmm, nice! ü§∑‚Äç‚ôÄÔ∏è",
            "Omg, so cute! üòç",
            "Yaar, ye kahan se mila? üòÖ",
            "Aww, main save kar rahi hun! üíï",
            "Haha, ye bahut funny hai! üòÇ",
            "Yaar, ye sticker collection se hai? üòä",
            "So adorable! ü•∞",
            "Hmm, interesting choice! ü§î",
            "Yaar, ye kya cute hai! üíñ",
            "Acha, main bhi bhejti hun! üòè",
            "Haha, ye perfect hai! üòÜ"
        ]
        await message.reply_text(random.choice(sticker_responses))
